contents
	I, foundations
		introduction
			1, the role of algorithms in computing
				1.1 algorithms
				1.2 algorithms as a technology
			2, getting started
				2.1 insertion sort
				2.2 analyzing algorithms
				2.3 designing algorithms
			3, characterizing running times
				3.1 o notation, omega notation, and theta notation
				3.2 asymptotic notation: formal definitions
			4, divide-and-conquer
				4.1 multiplying square matrices
				4.2 Strassen's algorithm for matrix multiplication
				4.3 the substitution method for solving recurrences
				4.4 the recursion-tree method for solving recurrences
				4.5 the master method for solving recurrences
				4.6 proof of the continuous master theorem
				4.7 Akra-Bazzi recurrences
			5, probabilistic analysis and randomized algorithms
				5.1 the hiring problem
				5.2 indicator random variables
				5.3 randomized algorithms
				5.4 probabilistic analysis and further uses of indicator random variables
	II, sorting and order statistics
		introduction
			6, heap sort
				6.1 heap sort
				6.2 maintaining the heap property
				6.3 building a heap
				6.4 the heap sort algorithm
				6.5 priority queues
			7, quick sort
				7.1 description of quick sort
				7.2 performance of quick sort
				7.3 a randomized version of quick sort
				7.4 analysis of quick sort
			8, sorting in linear time
				8.1 lower bounds for sorting
				8.2 counting sort
				8.3 radix sort
				8.4 bucket sort
			9, medians and order statistics
				9.1 minimum and maximum
				9.2 selection in expected linear time
				9.3 selection in worst-case linear time
	III, data structures
		introduction
			10, elementary data structures
				10.1 simple array-based data structures: arrays, matrices, stacks, queues
				10.2 linked lists
				10.3 representing rooted trees
			11, hash tables
				11.1 direct-address tables
				11.2 hash tables
				11.3 hash functions
				11.4 open addressing
				11.5 practical considerations
			12, binary search trees
				12.1 what is a binary search tree?
				12.2 querying a binary search tree
				12.3 insertion and deletion
			13 red-black trees
				13.1 properties of red-black trees
				13.2 rotations
				13.3 insertion
				13.4 deletion
	IV, advanced design and analysis techniques
		introduction
			14, dynamic programming
				14.1 rod cutting
				14.2 matrix-chain multiplication
				14.3 elements of dynamic programming
				14.4 longest common subsequent
				14.5 optimal binary search trees
			15, greedy algorithms
				15.1 an activity-selection problem
				15.2 elements of the greedy strategy
				15.3 Huffman codes
				15.4 offline caching
			16, amortized analysis #amortization 
				16.1 aggregate analysis
				16.2 the accounting method
				16.3 the potential method
				16.4 dynamic tables
	V, advanced data structures
		introduction
			17, augmenting data structures
				17.1 dynamic order statistics
				17.2 how to augment a data structure
				17.3 interval trees
			18, b-trees
				18.1 definition of b-trees
				18.2 basic operations on b-trees
				18.3 deleting a key from a b-tree
			19, data structures for disjoint sets
				19.1 disjoint-set operations
				19.2 linked-list representation of disjoint sets
				19.3 disjoint-set forests
				19.4 analysis of union of by rank with path compression
	VI, graph algorithms
		introduction
			20, elementary graph algorithms
				20.1 representations of graphs
				20.2 breadth-first search
				20.3 depth-first search
				20.4 topological sort
				20.5 strongly connected components
			21, minimum spanning trees
				21.1 growing a minimum spanning tree
				21.2 the algorithms of Kruskal and Prim
			22, single-source shortest paths
				22.1 the bellman-form algorithm
				22.2 single-source shortest paths in directed acyclic graphs
				22.3 dijkstra's algorithm
				22.4 difference constraints and shortest paths
				22.5 proofs of shortest-paths properties
			23, all-pairs shortest paths
				23.1 shortest paths and matrix multiplication
				23.2 the Floyd-Warshall algorithm
				23.3 Johnson's algorithm for sparse graphs
			24, Maximum Flow
				24.1 flow networks
				24.2 the Ford-Fulkerson method
				24.3 maximum bipartite matching
			25, Matchings in Bipartite Graphs
				25.1 maximum 
				25.2 the stable-marriage problem
				25.3 the Hungarian algorithm for the assignment problem
	VII, selected topics
			26, parallel algorithms
				26.1 the basics of fork-join algorithm
				26.2 parallel matrix multiplication
				26.3 parallel merge sort
			27, online algorithms
				27.1 waiting for an elevator
				27.2 maintaining a search list
				27.3 online caching
			28, matrix operations
				28.1 solving systems of linear equations
				28.2 inverting matrices
				28.3 symmetric positive-definite matrices and least-square...
					...approximation
			29, linear programming
				29.1 linear programming formulations and algorithms
				29.2 formulating problems as linear programs
				29.3 duality
			30, polynomials and the fast Fourier transformation
				30.1, representing polynomials
				30.2, the DFT, and the FFT
				30.3, FFT circuits
			31, number-theoretic algorithms
				31.1 elementary number-theoretic algorithms
				31.2 greatest common divisor
				31.3 modular arithmetic
				31.4 solving modular linear equations
				31.5 the Chinese remainder theorem
				31.6 powers of an element
				31.7 the RSA public-key cryptosystem
				31.8 primality testing
			32, string matching
				32.1 the naive string-matching algorithm
				32.2 the Rabin-Karp algorithm
				32.3 string matching with finite automata
				32.4 the Knuth-Morris-Pratt algorithm
				32.5 suffix arrays
			33, machine-learning algorithm
				33.1 clustering
				33.2 multiplicative-weights algorithms
				33.3 gradient descent
			34, np-completeness
				34.1 polynomial time
				34.2 polynomial-time verification
				34.3 np-completeness reducability
				34.4 np-completeness proofs
				34.5 no-complete problems
			35, approximation algorithms
				35.1 the vertex-cover problem
				35.2 the traveling-salesperson problem
				35.3 the set-covering problem
				35.4 ranomization and linear programming
				35.5 the subset-sum problem
		VIII, appendix: mathematical background
			introduction
			A summations
				A.1 summation formulas and properties
				A.2 bounding summations
			B sets, etc
				B.1 sets
				B.2 relations
				B.3 functions
				B.4 graphs
				B.5 trees
			C counting and probability
				C.1 counting
				C.2 probability
				C.3 discrete random variables
				C.4 the geometric and binomial distributions
				C.5 the tails of binomial distribution
			D matrices
				D.1 matrices and matrix operations
				D.2 basic matrix properties
			bibligraphy
			index